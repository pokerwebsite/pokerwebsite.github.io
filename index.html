<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poker</title>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8762519418851741"
     crossorigin="anonymous"></script>
</head>
<body>
    <style>
        body { 
            margin:0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; 
            min-height:100vh; 
            position:relative; 
            background: linear-gradient(135deg, #0d7a3d 0%, #0a5a2e 100%);
            background-attachment: fixed;
        }
        .screen { 
            position:absolute; 
            inset:0; 
            display:flex; 
            flex-direction:column; 
            align-items:center; 
            justify-content:flex-start; 
            padding:24px; 
            background:transparent; 
            opacity:0; 
            pointer-events:none; 
            transition:opacity 300ms ease; 
        }
        .screen.active { opacity:1; pointer-events:auto; }
        
        /* Username screen larger */
        #usernamePage { gap:12px; display:flex; align-items:center; justify-content:center; }
        #usernamePage h2 { 
            font-size:32px; 
            margin:0; 
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        #usernamePage input { 
            font-size:18px; 
            padding:12px 16px; 
            width:360px; 
            border: 2px solid #0a5a2e;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }
        #usernamePage button, #btnSet {
            font-size: 18px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #d4af37 0%, #b8941a 100%);
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #usernamePage button:hover, #btnSet:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.4);
        }
        #usernamePage button:active, #btnSet:active {
            transform: translateY(0);
        }

        /* Lobby centered and larger controls */
        #lobbyScreen { gap:12px; justify-content:center; align-items:center; }
        #lobbyScreen .lobbyControls { display:flex; gap:12px; align-items:center; font-size:18px; }
        #lobbyScreen .lobbyControls button { 
            font-size:16px; 
            padding:10px 20px; 
            background: linear-gradient(135deg, #d4af37 0%, #b8941a 100%);
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #lobbyScreen .lobbyControls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.4);
        }
        #lobbyScreen .lobbyControls input { 
            font-size:16px; 
            padding:10px 16px; 
            border: 2px solid #0a5a2e;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        #gameScreen { gap:12px; }
        
        /* Start button and waiting text positioning */
        #startGameButton, #waitingForHost {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 2000;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        #startGameButton {
            background: linear-gradient(135deg, #d4af37 0%, #b8941a 100%);
            color: #fff;
            cursor: pointer;
        }
        
        #startGameButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.5);
        }
        
        #startGameButton:active {
            transform: translateY(0);
        }
        
        #waitingForHost {
            background: rgba(255, 255, 255, 0.95);
            color: #0a5a2e;
            padding: 12px 20px;
        }
        
        #gameCodeDisplay {
            position: fixed;
            top: 70px;
            left: 20px;
            z-index: 2000;
            background: rgba(255, 255, 255, 0.95);
            color: #0a5a2e;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        /* Button styling improvements */
        button:not(#startGameButton):not(#waitingForHost) {
            background: linear-gradient(135deg, #d4af37 0%, #b8941a 100%);
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:not(#startGameButton):not(#waitingForHost):hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.4);
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #999;
        }
        
        input[type="number"], input[type="text"] {
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 10px 14px;
            background: rgba(255,255,255,0.95);
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }
        
        /* Table visualization styles */
        #pokerTable {
            position: relative;
            width: 600px;
            height: 400px;
            margin: 20px auto;
        }
        
        .table-surface {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 250px;
            background: linear-gradient(135deg, #1a5c2e 0%, #0d3d1f 100%);
            border: 8px solid #8B4513;
            border-radius: 50%;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 50px rgba(0,0,0,0.3);
        }
        
        .table-pot {
            position: absolute;
            /* moved further down to avoid overlap */
            top: 78%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            font-weight: 700;
            color: #d4af37;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
        }

        /* card back / hover reveal for hole cards */
        .card-wrapper {
            position: relative;
            width: 56px;
            /* make wrapper slightly taller so back can overhang */
            height: 86px;
            perspective: 600px;
        }
        /* Showdown area styles */
        #showdownArea {
            pointer-events: none;
        }
        .showdown-player {
            background: rgba(255,255,255,0.98);
            padding: 8px 10px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 90px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.25);
        }
        .showdown-card {
            font-size: 12px;
            border: 1px solid rgba(0,0,0,0.08);
            border-radius: 6px;
            padding: 6px;
            background: #fff;
        }
        .card-face, .card-back {
            position: absolute;
            /* slightly larger than wrapper so back covers fully */
            inset: -2px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            padding: 6px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.22), inset 0 1px 0 rgba(255,255,255,0.8);
            backface-visibility: hidden;
            transition: transform 0.16s ease, opacity 0.16s ease, visibility 0.16s;
        }
        .card-face { visibility: hidden; opacity: 0; z-index: 3; }
        .card-back {
            background: linear-gradient(135deg,#2e6b3a 0%,#1f4b2a 100%);
            color: #fff;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            text-align: center;
            font-size: 11px;
            z-index: 2;
        }
        .card-wrapper:hover .card-face { visibility: visible; opacity: 1; z-index: 4; }
        .card-wrapper:hover .card-back { visibility: hidden; opacity: 0; z-index: 1; }
        
        .player-seat {
            position: absolute;
            background: rgba(255,255,255,0.95);
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 14px;
            color: #0a5a2e;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            min-width: 100px;
            text-align: center;
            border: 2px solid transparent;
        }
        
        .player-seat.current-turn {
            /* highlight removed — keep same appearance as normal seats */
            background: rgba(255,255,255,0.95);
            border: 2px solid transparent;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: none;
        }
        
        @keyframes glow {
            from {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 4px 12px rgba(0,0,0,0.3);
            }
            to {
                box-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 4px 12px rgba(0,0,0,0.3);
            }
        }
        
        .player-seat.chip-added {
            animation: chipPulse 0.6s ease-out;
        }
        
        @keyframes chipPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1); }
        }
        
        .player-seat.user-seat {
            background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
            color: #fff;
            border: 2px solid #2a6fa8;
        }
    </style>

    <div id="usernamePage" class="screen active">
        <h2>Set Username</h2>
        <input type="text" id="txtUsername" placeholder="Enter username">
        <button id="btnSet">Set Username</button>
    </div>

    <div id="lobbyScreen" class="screen" style="display:flex;">
        <div class="lobbyControls">
            <button id="btnCreate">New Game</button>
            <button id="btnJoin">Join Game</button>
            <input type="text" id="txtGameId" placeholder="Game ID">
        </div>
        <div id="divPlayers" style="margin-top:18px; width:100%; max-width:640px;"></div>
    </div>

    <div id="gameScreen" class="screen">
        <div id="divBoard" style="width:100%; max-width:900px; min-height:240px;"></div>
    </div>
    <script>
        //HTML elements
        let clientId = null;
        let gameId = null;
        let playerColor = null;
        let username = null;
        let pot = 0;
        let ws = new WebSocket("https://tryna.fightinsans.workers.dev/")
        // client-side timer state
        let clientTimerInterval = null;
        let clientTimerRemaining = 0;
        let clientTimerOwner = null;
        // latest game snapshot used by the timer interval to avoid stale closure values
        let currentGameState = null;
        const btnCreate = document.getElementById("btnCreate");
        const btnJoin = document.getElementById("btnJoin");
        const txtGameId = document.getElementById("txtGameId");
        const divPlayers = document.getElementById("divPlayers");
        const divBoard = document.getElementById("divBoard");
        let messagesContainer = null; // created only when player is in the game
        const txtUsername = document.getElementById("txtUsername");
        const btnSet = document.getElementById("btnSet");
        const usernamePage = document.getElementById("usernamePage");
        let amountAdded = 0;
        let prevRound = null;
        
        // screen switching helper (username, lobby, game)
        function showScreen(id){
            const screens = document.querySelectorAll('.screen');
            screens.forEach(s => s.classList.remove('active'));
            const target = document.getElementById(id);
            if (target) {
                target.classList.add('active');
                // minor focus management
                const input = target.querySelector('input');
                if (input) input.focus();
                // if switching to lobby, remove any game-specific UI so only lobby controls remain
                if (id === 'lobbyScreen') {
                    try { removeAllGameGraphics(); } catch (e) { console.error('cleanup on lobby switch failed', e); }
                }
            }
        }
    
        //wiring events
        btnJoin.addEventListener("click", e => {

            if (gameId === null)
                gameId = txtGameId.value;
            
            const payLoad = {
                "method": "join",
                "clientId": clientId,
                "gameId": gameId,
                "name": username
            }

            wsSend(JSON.stringify(payLoad));

        })
        btnSet.addEventListener("click", e => {
            const val = txtUsername.value && txtUsername.value.trim();
            if (!val) {
                showError("Please enter a username");
                return;
            }
            username = val;
            showScreen('lobbyScreen');
        })
        btnCreate.addEventListener("click", e => {

            const payLoad = {
                "method": "create",
                "clientId": clientId
            }

            wsSend(JSON.stringify(payLoad));
        })

        ws.onmessage = message => {
            //message.data
            const response = JSON.parse(message.data);
            //connect
            if (response.method === "connect"){
                clientId = response.clientId;
                console.log("Client id Set successfully " + clientId)
            }
            

            //create
            if (response.method === "create"){
                gameId = response.game.id;
                console.log("game successfully created with id " + response.game.id + " with " + response.game.balls + " balls")  
                const payLoad = {
                "method": "join",
                "clientId": clientId,
                "gameId": response.game.id,
                "name": username
                }
                wsSend(JSON.stringify(payLoad));
            }
            //error
            if (response.method === "error"){
                showError(response.error);
                console.log(response.amountadded)
                return;
            }

            // left: server confirms this client has left the game
            if (response.method === 'left'){
                try { removeAllGameGraphics(); } catch(e){}
                try { removeLeaveButton(); } catch(e){}
                gameId = null;
                amountAdded = 0;
                prevRound = null;
                showScreen('lobbyScreen');
                return;
            }


            // 'add' from server (e.g., blinds posted) — treat as a lightweight update
            if (response.method === "add"){
                const game = response.game || {};
                // update pot/value display
                let value = null;
                if (typeof game.value === 'number') value = game.value;
                else if (typeof game.state === 'number') value = game.state;
                else if (game.state && typeof game.state.value === 'number') value = game.state.value;
                const display = document.getElementById('numberDisplay');
                if (value !== null && value !== undefined && display) display.textContent = String(value);
                // basic UI sync
                const roundDisplay = document.getElementById('roundDisplay');
                if (roundDisplay) roundDisplay.textContent = 'Round: ' + (game.round || 0) + ' / ' + (game.totalRounds || 0);
                const target = typeof game.max === 'number' ? game.max : 0;
                const maxDisplay = document.getElementById('maxDisplay'); if (maxDisplay) maxDisplay.textContent = 'Target: ' + target;
                const myAdded = (game.amountsAdded && typeof game.amountsAdded[clientId] === 'number') ? game.amountsAdded[clientId] : 0;
                const required = Math.max(0, target - myAdded);
                const requiredAddDisplay = document.getElementById('requiredAddDisplay'); if (requiredAddDisplay) requiredAddDisplay.textContent = 'Minimum add: ' + (typeof game.max === 'number' ? game.max : 0);
                const yourAddedDisplay = document.getElementById('yourAddedDisplay'); if (yourAddedDisplay) yourAddedDisplay.textContent = 'You added: ' + myAdded;
                const vElm = document.getElementById('yourChipsValue'); if (vElm) vElm.textContent = String((game.chips && typeof game.chips[clientId] === 'number') ? game.chips[clientId] : 0);
                // update player tiles and timer
                updatePlayerList(game);
                updateTimerDisplay(game);
                // show messages and community if in game
                const amIInGame = Array.isArray(game.clients) && game.clients.some(c => c.clientId === clientId);
                if (amIInGame) {
                    ensureMessagesContainer(); if (Array.isArray(game.messages)) renderMessages(game.messages);
                    if (game.started) updateTurnIndicator(game.currentTurnName || ''); else removeTurnIndicator();
                    ensureCommunityContainer(); if (Array.isArray(game.community)) renderCommunity(game.community, game.round);
                    ensureYourChipsContainer(); updatePlayerList(game);
                    ensureLeaveButton();
                }
            }
            //update: expect a single numeric value for the game
            if (response.method === "update"){
                const game = response.game || {};
                let value = null;
                if (typeof game.value === 'number') value = game.value;
                else if (typeof game.state === 'number') value = game.state;
                else if (game.state && typeof game.state.value === 'number') value = game.state.value;
                const display = document.getElementById('numberDisplay');
                if (value !== null && value !== undefined && display) display.textContent = String(value);
                console.log(game.max)
                // update round and turn if present
                const roundDisplay = document.getElementById('roundDisplay');
                if (roundDisplay) roundDisplay.textContent = 'Round: ' + (game.round || 0) + ' / ' + (game.totalRounds || 0);
                // Turn display is handled by the persistent turn indicator below the chat

                // reset local per-round added counters if round changed
                if (typeof game.round === 'number' && prevRound !== game.round){
                    amountAdded = 0;
                    const yourAddedDisplay = document.getElementById('yourAddedDisplay');
                    if (yourAddedDisplay) yourAddedDisplay.textContent = 'You added: 0';
                    const addInput = document.getElementById('addInput');
                    if (addInput) addInput.value = '';
                    prevRound = game.round;
                }

                // display target (game.max) and per-client added amounts
                const target = typeof game.max === 'number' ? game.max : 0;
                const maxDisplay = document.getElementById('maxDisplay');
                if (maxDisplay) maxDisplay.textContent = 'Target: ' + target;

                const requiredAddDisplay = document.getElementById('requiredAddDisplay');
                const yourAddedDisplay = document.getElementById('yourAddedDisplay');
                const yourChipsValue = document.getElementById('yourChipsValue');
                const myAdded = (game.amountsAdded && typeof game.amountsAdded[clientId] === 'number') ? game.amountsAdded[clientId] : 0;
                const required = Math.max(0, target - myAdded);
                if (requiredAddDisplay) requiredAddDisplay.textContent = 'Minimum add: ' + (typeof game.max === 'number' ? game.max : 0);
                if (yourAddedDisplay) yourAddedDisplay.textContent = 'You added: ' + myAdded;
                const myChips = (game.chips && typeof game.chips[clientId] === 'number') ? game.chips[clientId] : 0;
                if (yourChipsValue) yourChipsValue.textContent = String(myChips);
                
                // Update player list
                updatePlayerList(game);
                    updateTimerDisplay(game);
                // update global turn timer display
                updateTimerDisplay(game);

                // create/show messages only if this client is in the game
                const amIInGame = Array.isArray(game.clients) && game.clients.some(c => c.clientId === clientId);
                if (amIInGame) {
                    ensureMessagesContainer();
                    if (Array.isArray(game.messages)) renderMessages(game.messages);
                    // update turn indicator (only if game has started)
                    if (game.started) {
                        updateTurnIndicator(game.currentTurnName || '');
                    } else {
                        removeTurnIndicator();
                    }
                    // community area
                    ensureCommunityContainer();
                    if (Array.isArray(game.community)) renderCommunity(game.community, game.round);
                    // show chips widget
                    ensureYourChipsContainer();
                    updatePlayerList(game);
                    updateTimerDisplay(game);
                    updateTimerDisplay(game);
                    ensureLeaveButton();
                    const vElm = document.getElementById('yourChipsValue');
                    if (vElm) vElm.textContent = String((game.chips && typeof game.chips[clientId] === 'number') ? game.chips[clientId] : 0);
                    // show blind notice on start if applicable
                    const sbIndexStart = typeof game.smallBlindIndex === 'number' ? game.smallBlindIndex : null;
                    const bbIndexStart = typeof game.bigBlindIndex === 'number' ? game.bigBlindIndex : null;
                    const sbIdStart = (Array.isArray(game.clients) && sbIndexStart !== null && game.clients[sbIndexStart]) ? game.clients[sbIndexStart].clientId : null;
                    const bbIdStart = (Array.isArray(game.clients) && bbIndexStart !== null && game.clients[bbIndexStart]) ? game.clients[bbIndexStart].clientId : null;
                    // Only show blind notices in first round
                    const currentRound = typeof game.round === 'number' ? game.round : 0;
                    if (currentRound <= 1) {
                        if (clientId === bbIdStart) { showBlindNotice('You are the Big Blind'); }
                        else if (clientId === sbIdStart) { showBlindNotice('You are the Small Blind'); }
                        else { clearBlindNotice(); }
                        // show blind notice if this client is small or big blind
                        const sbIndex = typeof game.smallBlindIndex === 'number' ? game.smallBlindIndex : null;
                        const bbIndex = typeof game.bigBlindIndex === 'number' ? game.bigBlindIndex : null;
                        const sbId = (Array.isArray(game.clients) && sbIndex !== null && game.clients[sbIndex]) ? game.clients[sbIndex].clientId : null;
                        const bbId = (Array.isArray(game.clients) && bbIndex !== null && game.clients[bbIndex]) ? game.clients[bbIndex].clientId : null;
                        if (clientId === bbId) {
                            showBlindNotice('You are the Big Blind');
                        } else if (clientId === sbId) {
                            showBlindNotice('You are the Small Blind');
                        } else {
                            clearBlindNotice();
                        }
                    } else {
                        clearBlindNotice();
                    }
                    // Trigger showdown animation if present and not previously shown
                    if (game.showdown && game.showdown.players && Object.keys(game.showdown.players).length > 0) {
                        const key = JSON.stringify(game.showdown.players);
                        if (lastShowdownKey !== key) {
                            lastShowdownKey = key;
                            setTimeout(()=> startShowdownAnimation(game), 60);
                        }
                    }
                } else {
                    removeMessagesContainer();
                    removeTurnIndicator();
                    removeCommunityContainer();
                    removeYourChipsContainer();
                    removeLeaveButton();
                }

                // enable/disable inputs based on turn and gray them out
                const addInput = document.getElementById('addInput');
                const addBtn = document.getElementById('addBtn');
                const checkBtn = document.getElementById('checkBtn');
                const foldBtn = document.getElementById('foldBtn');
                const isMyTurn = (() => {
                    if (!game.started || game.ended) return false;
                    const ti = typeof game.turnIndex === 'number' ? game.turnIndex : 0;
                    const current = (game.clients || [])[ti];
                    return current && current.clientId === clientId;
                })();
                
                // Check if player can check (their amountAdded equals the max)
                const myAddedForCheck = (game.amountsAdded && typeof game.amountsAdded[clientId] === 'number') ? game.amountsAdded[clientId] : 0;
                const targetForCheck = typeof game.max === 'number' ? game.max : 0;
                const canCheck = myAddedForCheck >= targetForCheck;
                
                if (addInput) {
                    addInput.disabled = !isMyTurn;
                    addInput.min = Math.max(1, required);
                    addInput.style.background = addInput.disabled ? 'rgba(238,238,238,0.7)' : 'rgba(255,255,255,0.95)';
                    addInput.style.opacity = addInput.disabled ? '0.6' : '1';
                }
                if (addBtn) {
                    addBtn.disabled = !isMyTurn;
                    addBtn.style.opacity = addBtn.disabled ? '0.6' : '1';
                }
                if (checkBtn) {
                    checkBtn.disabled = !isMyTurn || !canCheck;
                    checkBtn.style.opacity = (!isMyTurn || !canCheck) ? '0.6' : '1';
                }
                if (foldBtn) {
                    foldBtn.disabled = !isMyTurn;
                    foldBtn.style.opacity = foldBtn.disabled ? '0.6' : '1';
                }
                // remember current chips snapshot for next showdown comparison
                previousChips = Object.assign({}, game.chips || {});
            }

            //start: server signals that the game has started; render numeric UI
            if (response.method === "start"){
                const game = response.game || {};
                // Remove start button and waiting text when game starts
                const existingStartBtn = document.getElementById('startGameButton');
                const existingWaiting = document.getElementById('waitingForHost');
                const existingGameCode = document.getElementById('gameCodeDisplay');
                if (existingStartBtn) existingStartBtn.remove();
                if (existingWaiting) existingWaiting.remove();
                if (existingGameCode) existingGameCode.remove();
                // clear board and controls overlay
                while(divBoard.firstChild) divBoard.removeChild(divBoard.firstChild);
                removeControlsOverlay();

                // ensure board positioning for centered pot
                divBoard.style.position = 'center';
                divBoard.style.minHeight = '360px';

                const numberContainer = document.createElement('div');
                numberContainer.style.position = 'absolute';
                numberContainer.style.top = '30%';
                numberContainer.style.left = '50%';
                numberContainer.style.transform = 'translate(-50%, -50%)';
                numberContainer.style.display = 'flex';
                numberContainer.style.flexDirection = 'column';
                numberContainer.style.alignItems = 'center';
                numberContainer.style.gap = '10px';
                const headerRow = document.createElement('div');
                headerRow.style.display = 'flex';
                headerRow.style.gap = '16px';
                headerRow.style.flexWrap = 'wrap';
                headerRow.style.justifyContent = 'center';
                headerRow.style.padding = '12px';
                headerRow.style.background = 'rgba(255,255,255,0.1)';
                headerRow.style.borderRadius = '8px';
                headerRow.style.marginBottom = '8px';

                const roundDisplay = document.createElement('div');
                roundDisplay.id = 'roundDisplay';
                roundDisplay.textContent = 'Round: ' + (game.round || 0) + ' / ' + (game.totalRounds || 0);
                roundDisplay.style.color = '#fff';
                roundDisplay.style.fontWeight = '600';
                roundDisplay.style.textShadow = '1px 1px 2px rgba(0,0,0,0.5)';
                headerRow.appendChild(roundDisplay);


                const requiredAddDisplay = document.createElement('div');
                requiredAddDisplay.id = 'requiredAddDisplay';
                requiredAddDisplay.textContent = 'Minimum add: 0';
                requiredAddDisplay.style.color = '#fff';
                requiredAddDisplay.style.fontWeight = '600';
                requiredAddDisplay.style.textShadow = '1px 1px 2px rgba(0,0,0,0.5)';
                headerRow.appendChild(requiredAddDisplay);

                const yourAddedDisplay = document.createElement('div');
                yourAddedDisplay.id = 'yourAddedDisplay';
                yourAddedDisplay.textContent = 'You added: 0';
                yourAddedDisplay.style.color = '#fff';
                yourAddedDisplay.style.fontWeight = '600';
                yourAddedDisplay.style.textShadow = '1px 1px 2px rgba(0,0,0,0.5)';
                headerRow.appendChild(yourAddedDisplay);

                // chips widget moved to bottom-left; created via ensureYourChipsContainer()

                numberContainer.appendChild(headerRow);

                const display = document.createElement('div');
                display.id = 'numberDisplay';
                display.textContent = String(game.value != null ? game.value : (game.state && game.state.value != null ? game.state.value : 0));
                display.style.fontSize = '64px';
                display.style.fontWeight = '700';
                display.style.width = '240px';
                display.style.textAlign = 'center';
                display.style.border = '3px solid #d4af37';
                display.style.borderRadius = '12px';
                display.style.padding = '24px';
                display.style.background = 'rgba(255,255,255,0.95)';
                display.style.color = '#0a5a2e';
                display.style.boxShadow = '0 8px 24px rgba(0,0,0,0.3)';
                numberContainer.appendChild(display);

                // create controls overlay (bottom-center) and attach inputs there
                removeControlsOverlay();
                const controlsOverlay = document.createElement('div');
                controlsOverlay.id = 'controlsOverlay';
                controlsOverlay.style.position = 'fixed';
                controlsOverlay.style.bottom = '20px';
                controlsOverlay.style.left = '50%';
                controlsOverlay.style.transform = 'translateX(-50%)';
                controlsOverlay.style.display = 'flex';
                controlsOverlay.style.gap = '12px';
                controlsOverlay.style.alignItems = 'center';
                controlsOverlay.style.padding = '12px 16px';
                controlsOverlay.style.background = 'rgba(255,255,255,0.95)';
                controlsOverlay.style.borderRadius = '12px';
                controlsOverlay.style.boxShadow = '0 8px 24px rgba(0,0,0,0.3)';
                controlsOverlay.style.zIndex = '1000';

                const input = document.createElement('input');
                input.type = 'number';
                input.id = 'addInput';
                input.placeholder = 'Amount';
                input.style.width = '140px';
                input.style.fontSize = '16px';
                input.step = '1';
                input.min = '1';

                const addBtn = document.createElement('button');
                addBtn.id = 'addBtn';
                addBtn.textContent = 'Add';
                    addBtn.addEventListener('click', () => {
                        const v = Number(input.value);
                        if (Number.isNaN(v) || !Number.isInteger(v) || v <= 0) { showError('Enter a whole number greater than 0'); return; }
                    const payLoad = {
                        method: 'add',
                        clientId: clientId,
                        gameId: response.gameId || gameId,
                        value: v,
                        name: username
                    };
                    amountAdded = (amountAdded || 0) + v;
                    wsSend(JSON.stringify(payLoad));
                });

                const checkBtn = document.createElement('button');
                checkBtn.id = 'checkBtn';
                checkBtn.textContent = 'Check';
                checkBtn.addEventListener('click', () => {
                    const payLoad = {
                        method: 'add',
                        clientId: clientId,
                        gameId: response.gameId || gameId,
                        value: 0,
                        name: username
                    };
                    wsSend(JSON.stringify(payLoad));
                });

                const foldBtn = document.createElement('button');
                foldBtn.id = 'foldBtn';
                foldBtn.textContent = 'Fold';
                foldBtn.addEventListener('click', () => {
                    const payLoad = { method: 'fold', clientId: clientId, gameId: response.gameId || gameId };
                    wsSend(JSON.stringify(payLoad));
                });

                controlsOverlay.appendChild(input);
                controlsOverlay.appendChild(addBtn);
                controlsOverlay.appendChild(checkBtn);
                controlsOverlay.appendChild(foldBtn);
                document.body.appendChild(controlsOverlay);
                // create cards area above controls (your cards) with label
                removeCardsOverlay();
                const cardsOverlay = document.createElement('div');
                cardsOverlay.id = 'cardsOverlay';
                cardsOverlay.style.position = 'fixed';
                cardsOverlay.style.bottom = '120px';
                cardsOverlay.style.left = '50%';
                cardsOverlay.style.transform = 'translateX(-50%)';
                cardsOverlay.style.display = 'flex';
                cardsOverlay.style.flexDirection = 'column';
                cardsOverlay.style.gap = '12px';
                cardsOverlay.style.alignItems = 'center';
                cardsOverlay.style.zIndex = '1100';
                // label
                const yourLabel = document.createElement('div');
                yourLabel.textContent = 'Your cards';
                yourLabel.style.fontWeight = '700';
                yourLabel.style.fontSize = '18px';
                yourLabel.style.color = '#fff';
                yourLabel.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
                yourLabel.style.marginBottom = '4px';
                cardsOverlay.appendChild(yourLabel);
                const cardsRow = document.createElement('div');
                cardsRow.style.display = 'flex';
                cardsRow.style.gap = '12px';
                cardsRow.id = 'cardsRow';
                cardsOverlay.appendChild(cardsRow);
                document.body.appendChild(cardsOverlay);

                if (Array.isArray(response.privateHand)) {
                    renderCards(response.privateHand);
                }
                // render community if present
                if (Array.isArray(game.community)){
                    ensureCommunityContainer();
                    renderCommunity(game.community, game.round);
                } else {
                    removeCommunityContainer();
                }

                divBoard.appendChild(numberContainer);
                // messages only for players in game (start always shows messages to players who joined)
                const amIInGameStart = Array.isArray(game.clients) && game.clients.some(c=>c.clientId===clientId);
                if (amIInGameStart) {
                    ensureMessagesContainer();
                    if (Array.isArray(game.messages)) renderMessages(game.messages);
                    // Only show turn indicator if game has started
                    if (game.started) {
                        updateTurnIndicator(game.currentTurnName || '');
                    } else {
                        removeTurnIndicator();
                    }
                    // reset local per-round counters on start as well
                    ensureYourChipsContainer();
                    updatePlayerList(game);
                    const sbIndexJoin = typeof game.smallBlindIndex === 'number' ? game.smallBlindIndex : null;
                    const bbIndexJoin = typeof game.bigBlindIndex === 'number' ? game.bigBlindIndex : null;
                    const sbIdJoin = (Array.isArray(game.clients) && sbIndexJoin !== null && game.clients[sbIndexJoin]) ? game.clients[sbIndexJoin].clientId : null;
                    const bbIdJoin = (Array.isArray(game.clients) && bbIndexJoin !== null && game.clients[bbIndexJoin]) ? game.clients[bbIndexJoin].clientId : null;
                    // Only show blind notices in first round
                    const currentRoundStart = typeof game.round === 'number' ? game.round : 0;
                    if (currentRoundStart <= 1) {
                        if (clientId === bbIdJoin) { showBlindNotice('You are the Big Blind'); }
                        else if (clientId === sbIdJoin) { showBlindNotice('You are the Small Blind'); }
                        else { clearBlindNotice(); }
                    } else {
                        clearBlindNotice();
                    }
                    const vElm = document.getElementById('yourChipsValue');
                    if (vElm) vElm.textContent = String((game.chips && typeof game.chips[clientId] === 'number') ? game.chips[clientId] : 0);
                    amountAdded = 0;
                    prevRound = game.round;
                    ensureLeaveButton();
                } else {
                    removeMessagesContainer();
                    removeYourChipsContainer();
                    removeLeaveButton();
                }
            }

            //join
            if (response.method === "join"){
                const game = response.game;
                // switch to in-game screen when we receive a join payload
                showScreen('gameScreen');
                gameId = response.gameId || (game && game.id) || gameId;

                while(divPlayers.firstChild)
                    divPlayers.removeChild(divPlayers.firstChild)
                const di = document.createElement("div");
                    di.style.width = "200px";
                    di.style.background = "rgba(255,255,255,0.95)";
                    di.style.padding = "10px 16px";
                    di.style.borderRadius = "8px";
                    di.style.boxShadow = "0 4px 12px rgba(0,0,0,0.2)";
                    di.style.color = "#0a5a2e";
                    di.style.fontWeight = "600";
                    di.textContent = "current game code: " + (response.gameId || (game && game.id));
                    divPlayers.appendChild(di);
                // show chat once players have joined (even before the game starts)
                const amIInGameNow = Array.isArray(game.clients) && game.clients.some(c => c.clientId === clientId);
                if (amIInGameNow) {
                    ensureMessagesContainer();
                    if (Array.isArray(game.messages)) renderMessages(game.messages);
                    // Only show turn indicator if game has started
                    if (game.started) {
                        updateTurnIndicator(game.currentTurnName || '');
                    } else {
                        removeTurnIndicator();
                    }
                    ensureCommunityContainer();
                    if (Array.isArray(game.community)) renderCommunity(game.community, game.round);
                    ensureYourChipsContainer();
                    updatePlayerList(game);
                } else {
                    removeMessagesContainer();
                    removeCommunityContainer();
                    removeYourChipsContainer();
                }
                while(divBoard.firstChild)
                    divBoard.removeChild (divBoard.firstChild)
                removeControlsOverlay();

                // If the game hasn't started yet, show start button to creator, else show waiting text
                if (!game.started) {
                    // Remove any existing start button or waiting text
                    const existingStartBtn = document.getElementById('startGameButton');
                    const existingWaiting = document.getElementById('waitingForHost');
                    const existingGameCode = document.getElementById('gameCodeDisplay');
                    if (existingStartBtn) existingStartBtn.remove();
                    if (existingWaiting) existingWaiting.remove();
                    if (existingGameCode) existingGameCode.remove();
                    
                    // Get game code
                    const currentGameId = gameId || (game && game.id) || (response.gameId);
                    
                    // Create game code display
                    const gameCodeDisplay = document.createElement('div');
                    gameCodeDisplay.id = 'gameCodeDisplay';
                    gameCodeDisplay.textContent = 'Game Code: ' + currentGameId;
                    document.body.appendChild(gameCodeDisplay);
                    
                    if (game.creator === clientId) {
                        const startBtn = document.createElement('button');
                        startBtn.id = 'startGameButton';
                        startBtn.textContent = 'Start Game';
                        startBtn.addEventListener('click', () => {
                            const payLoad = {
                                method: 'start',
                                clientId: clientId,
                                gameId: gameId
                            };
                            wsSend(JSON.stringify(payLoad));
                        });
                        document.body.appendChild(startBtn);
                    } else {
                        const waiting = document.createElement('div');
                        waiting.id = 'waitingForHost';
                        waiting.textContent = 'Waiting for host to start';
                        document.body.appendChild(waiting);
                    }
                } else {
                    // Remove start button and waiting text when game starts
                    const existingStartBtn = document.getElementById('startGameButton');
                    const existingWaiting = document.getElementById('waitingForHost');
                    const existingGameCode = document.getElementById('gameCodeDisplay');
                    if (existingStartBtn) existingStartBtn.remove();
                    if (existingWaiting) existingWaiting.remove();
                    if (existingGameCode) existingGameCode.remove();
                    // Numeric game UI
                    const numberContainer = document.createElement('div');
                    numberContainer.style.display = 'flex';
                    numberContainer.style.flexDirection = 'column';
                    numberContainer.style.alignItems = 'center';
                    numberContainer.style.gap = '10px';

                    const display = document.createElement('div');
                    display.id = 'numberDisplay';
                    display.textContent = String(game.value != null ? game.value : (game.state && game.state.value != null ? game.state.value : 0));
                    display.style.fontSize = '64px';
                    display.style.fontWeight = '700';
                    display.style.width = '240px';
                    display.style.textAlign = 'center';
                    display.style.border = '3px solid #d4af37';
                    display.style.borderRadius = '12px';
                    display.style.padding = '24px';
                    display.style.background = 'rgba(255,255,255,0.95)';
                    display.style.color = '#0a5a2e';
                    display.style.boxShadow = '0 8px 24px rgba(0,0,0,0.3)';
                    numberContainer.appendChild(display);

                    const maxDisplay = document.createElement('div');
                    maxDisplay.id = 'maxDisplay';
                    maxDisplay.textContent = 0;
                    maxDisplay.style.fontSize = '14px';
                    maxDisplay.style.fontWeight = '600';
                    maxDisplay.style.width = '240px';
                    maxDisplay.style.textAlign = 'center';
                    maxDisplay.style.padding = '12px';
                    maxDisplay.style.color = '#fff';
                    maxDisplay.style.textShadow = '1px 1px 2px rgba(0,0,0,0.5)';
                    numberContainer.appendChild(maxDisplay);

                    // create controls overlay for joined-started view instead of inline controls
                    removeControlsOverlay();
                    const controlsOverlay2 = document.createElement('div');
                    controlsOverlay2.id = 'controlsOverlay';
                    controlsOverlay2.style.position = 'fixed';
                    controlsOverlay2.style.bottom = '20px';
                    controlsOverlay2.style.left = '50%';
                    controlsOverlay2.style.transform = 'translateX(-50%)';
                    controlsOverlay2.style.display = 'flex';
                    controlsOverlay2.style.gap = '12px';
                    controlsOverlay2.style.alignItems = 'center';
                    controlsOverlay2.style.padding = '12px 16px';
                    controlsOverlay2.style.background = 'rgba(255,255,255,0.95)';
                    controlsOverlay2.style.borderRadius = '12px';
                    controlsOverlay2.style.boxShadow = '0 8px 24px rgba(0,0,0,0.3)';
                    controlsOverlay2.style.zIndex = '1000';

                    const input2 = document.createElement('input');
                    input2.type = 'number';
                    input2.id = 'addInput';
                    input2.placeholder = 'Amount';
                    input2.style.width = '140px';
                    input2.style.fontSize = '16px';
                    input2.step = '1';
                    input2.min = '1';

                    const addBtn2 = document.createElement('button');
                    addBtn2.id = 'addBtn';
                    addBtn2.textContent = 'Add';
                        addBtn2.addEventListener('click', () => {
                            const v = Number(input2.value);
                            if (Number.isNaN(v) || !Number.isInteger(v) || v <= 0) { showError('Enter a whole number greater than 0'); return; }
                        const payLoad = {
                            method: 'add',
                            clientId: clientId,
                            gameId: gameId,
                            value: v,
                            name: username
                        };
                        wsSend(JSON.stringify(payLoad));
                    });

                    const checkBtn2 = document.createElement('button');
                    checkBtn2.id = 'checkBtn';
                    checkBtn2.textContent = 'Check';
                    checkBtn2.addEventListener('click', () => {
                        const payLoad = { method: 'add', clientId: clientId, gameId: gameId, value: 0, name: username };
                        wsSend(JSON.stringify(payLoad));
                    });

                    const foldBtn2 = document.createElement('button');
                    foldBtn2.textContent = 'Fold';
                    foldBtn2.addEventListener('click', () => {
                        wsSend(JSON.stringify({ method: 'fold', clientId: clientId, gameId: gameId }));
                    });

                    controlsOverlay2.appendChild(input2);
                    controlsOverlay2.appendChild(addBtn2);
                    controlsOverlay2.appendChild(checkBtn2);
                    controlsOverlay2.appendChild(foldBtn2);
                    document.body.appendChild(controlsOverlay2);
                    // create cards overlay above controls
                        removeCardsOverlay();
                        const cardsOverlay2 = document.createElement('div');
                        cardsOverlay2.id = 'cardsOverlay';
                        cardsOverlay2.style.position = 'fixed';
                        cardsOverlay2.style.bottom = '120px';
                        cardsOverlay2.style.left = '50%';
                        cardsOverlay2.style.transform = 'translateX(-50%)';
                        cardsOverlay2.style.display = 'flex';
                        cardsOverlay2.style.flexDirection = 'column';
                        cardsOverlay2.style.gap = '12px';
                        cardsOverlay2.style.alignItems = 'center';
                        cardsOverlay2.style.zIndex = '1100';
                        const yourLabel2 = document.createElement('div');
                        yourLabel2.textContent = 'Your cards';
                        yourLabel2.style.fontWeight = '700';
                        yourLabel2.style.fontSize = '18px';
                        yourLabel2.style.color = '#fff';
                        yourLabel2.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
                        yourLabel2.style.marginBottom = '4px';
                        cardsOverlay2.appendChild(yourLabel2);
                        const cardsRow2 = document.createElement('div');
                        cardsRow2.style.display = 'flex';
                        cardsRow2.style.gap = '8px';
                        cardsRow2.id = 'cardsRow';
                        cardsOverlay2.appendChild(cardsRow2);
                        document.body.appendChild(cardsOverlay2);
                    // render community for joined-started view
                    if (Array.isArray(game.community)){
                        ensureCommunityContainer();
                        renderCommunity(game.community, game.round);
                    } else {
                        removeCommunityContainer();
                    }

                    // add round/turn and amounts displays for joined-started view
                    const headerRow = document.createElement('div');
                    headerRow.style.display = 'flex';
                    headerRow.style.gap = '16px';
                    headerRow.style.flexWrap = 'wrap';
                    headerRow.style.justifyContent = 'center';
                    headerRow.style.padding = '12px';
                    headerRow.style.background = 'rgba(255,255,255,0.1)';
                    headerRow.style.borderRadius = '8px';
                    headerRow.style.marginBottom = '8px';

                    const roundDisplay2 = document.createElement('div');
                    roundDisplay2.id = 'roundDisplay';
                    roundDisplay2.textContent = 'Round: ' + (game.round || 0) + ' / ' + (game.totalRounds || 0);
                    roundDisplay2.style.color = '#fff';
                    roundDisplay2.style.fontWeight = '600';
                    roundDisplay2.style.textShadow = '1px 1px 2px rgba(0,0,0,0.5)';
                    headerRow.appendChild(roundDisplay2);


                    const requiredAddDisplay2 = document.createElement('div');
                    requiredAddDisplay2.id = 'requiredAddDisplay';
                    requiredAddDisplay2.textContent = 'Minimum add: 0';
                    requiredAddDisplay2.style.color = '#fff';
                    requiredAddDisplay2.style.fontWeight = '600';
                    requiredAddDisplay2.style.textShadow = '1px 1px 2px rgba(0,0,0,0.5)';
                    headerRow.appendChild(requiredAddDisplay2);

                    const yourAddedDisplay2 = document.createElement('div');
                    yourAddedDisplay2.id = 'yourAddedDisplay';
                    yourAddedDisplay2.textContent = 'You added: 0';
                    yourAddedDisplay2.style.color = '#fff';
                    yourAddedDisplay2.style.fontWeight = '600';
                    yourAddedDisplay2.style.textShadow = '1px 1px 2px rgba(0,0,0,0.5)';
                    headerRow.appendChild(yourAddedDisplay2);

                    // chips widget moved to bottom-left; created via ensureYourChipsContainer()

                    numberContainer.insertBefore(headerRow, numberContainer.firstChild);

                    // render existing messages only if player is in game
                    const amIInGameJoin = Array.isArray(game.clients) && game.clients.some(c=>c.clientId===clientId);
                    if (amIInGameJoin) {
                        ensureMessagesContainer();
                        if (Array.isArray(game.messages)) renderMessages(game.messages);
                        // Only show turn indicator if game has started
                        if (game.started) {
                            updateTurnIndicator(game.currentTurnName || '');
                        } else {
                            removeTurnIndicator();
                        }
                    } else {
                        removeMessagesContainer();
                        removeTurnIndicator();
                    }

                    divBoard.appendChild(numberContainer);
                }




            }
        }

        function ensureMessagesContainer(){
            if (messagesContainer && document.body.contains(messagesContainer)) return;
            messagesContainer = document.createElement('div');
            messagesContainer.id = 'divMessages';
            messagesContainer.style.width = '300px';
            messagesContainer.style.maxHeight = '360px';
            messagesContainer.style.overflowY = 'auto';
            messagesContainer.style.border = '1px solid #ccc';
            messagesContainer.style.padding = '8px';
            messagesContainer.style.wordBreak = 'break-word';
            messagesContainer.style.position = 'fixed';
            messagesContainer.style.right = '20px';
            messagesContainer.style.top = '100px';
            messagesContainer.style.background = 'rgba(255,255,255,0.98)';
            messagesContainer.style.borderRadius = '12px';
            messagesContainer.style.border = '2px solid rgba(255,255,255,0.3)';
            messagesContainer.style.zIndex = '1000';
            messagesContainer.style.boxShadow = '0 8px 24px rgba(0,0,0,0.3)';
            document.body.appendChild(messagesContainer);
        }

        function removeMessagesContainer(){
            if (messagesContainer && messagesContainer.parentNode) {
                messagesContainer.parentNode.removeChild(messagesContainer);
            }
            messagesContainer = null;
        }

        // Turn indicator
        function ensureTurnIndicator(){
            if (document.getElementById('turnIndicator')) return;
            const d = document.createElement('div');
            d.id = 'turnIndicator';
            d.style.position = 'fixed';
            d.style.right = '20px';
            // Position below chat box: move slightly further down
            d.style.top = '540px';
            d.style.background = 'rgba(255,255,255,0.98)';
            d.style.color = '#0a5a2e';
            d.style.padding = '10px 16px';
            d.style.borderRadius = '8px';
            d.style.border = '2px solid rgba(255,255,255,0.3)';
            d.style.fontWeight = '600';
            d.style.fontSize = '14px';
            d.style.zIndex = '1000';
            d.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
            d.style.width = '300px';
            d.style.textAlign = 'center';
            d.textContent = 'Turn: -';
            document.body.appendChild(d);
        }

        // Timer visible to all players (top-left)
        function ensureTimerContainer(){
            if (document.getElementById('turnTimer')) return;
            const t = document.createElement('div');
            t.id = 'turnTimer';
            t.style.position = 'fixed';
            t.style.left = '16px';
            t.style.top = '16px';
            t.style.background = 'rgba(255,255,255,0.98)';
            t.style.color = '#0a5a2e';
            t.style.padding = '10px 14px';
            t.style.borderRadius = '10px';
            t.style.fontWeight = '800';
            t.style.fontSize = '18px';
            t.style.zIndex = '2000';
            t.style.boxShadow = '0 6px 18px rgba(0,0,0,0.25)';
            t.textContent = '';
            document.body.appendChild(t);
        }

        function updateTimerDisplay(game){
            if (!game) return;
            ensureTimerContainer();
            const t = document.getElementById('turnTimer');
            if (!t) return;
            const rem = typeof game.turnTimerRemaining === 'number' ? game.turnTimerRemaining : 0;
            const owner = game.turnTimerOwner || null;
            // sync client-side countdown to server value
            // keep a reference to latest game so the interval always reads current turn name
            currentGameState = game;
            if (rem > 0 && owner) {
                clientTimerRemaining = rem;
                clientTimerOwner = owner;
                // reset auto-fold flag whenever a new timer starts
                clientDidAutoFold = false;
                // start interval if not running
                if (!clientTimerInterval) {
                    clientTimerInterval = setInterval(() => {
                        clientTimerRemaining = Math.max(0, clientTimerRemaining - 1);
                        // always use the latest owner and latest game snapshot
                        renderClientTimer(clientTimerRemaining, clientTimerOwner, currentGameState);
                        if (clientTimerRemaining <= 0) {
                            clearInterval(clientTimerInterval);
                            clientTimerInterval = null;
                            clientTimerOwner = null;
                        }
                    }, 1000);
                }
                renderClientTimer(clientTimerRemaining, clientTimerOwner, currentGameState);
            } else {
                clientTimerRemaining = 0;
                clientTimerOwner = null;
                currentGameState = game;
                if (clientTimerInterval) { clearInterval(clientTimerInterval); clientTimerInterval = null; }
                t.textContent = '';
            }
        }

        let clientDidAutoFold = false;
        function renderClientTimer(remaining, owner, game){
            const t = document.getElementById('turnTimer');
            if (!t) return;
            const ownerName = (game && Array.isArray(game.clients)) ? (game.clients.find(p => p.clientId === owner)) : null;
            const displayName = ownerName && ownerName.name ? ownerName.name : (owner || '-');
            const turnName = (game && game.turn) ? game.turn : displayName;
            t.textContent = remaining > 0 ? `${turnName} — ${remaining}s` : '';
            // no yellow border — keep timer neutral
            t.style.border = '2px solid transparent';
            // if timer expired and this client was the owner, send fold once
            if (remaining <= 0 && owner === clientId && !clientDidAutoFold) {
                clientDidAutoFold = true;
                try {
                    const payLoad = { method: 'fold', clientId: clientId, gameId: game && game.id ? game.id : gameId };
                    if (ws && ws.readyState === WebSocket.OPEN) wsSend(JSON.stringify(payLoad));
                } catch (e) { console.error('auto-fold send error', e); }
            }
            // highlight entire screen and show message only when the game is started and it's your turn
            // additionally require the owner's displayed name to match this client's username
            if (game && game.started && owner === clientId && remaining > 0 && displayName === username) {
                showTurnHighlight();
            } else {
                hideTurnHighlight();
            }
        }

        function ensureTurnHighlight(){
            if (document.getElementById('turnHighlight')) return;
            const overlay = document.createElement('div');
            overlay.id = 'turnHighlight';
            overlay.style.position = 'fixed';
            overlay.style.inset = '0';
            overlay.style.pointerEvents = 'none';
            overlay.style.zIndex = '3000';
            overlay.style.display = 'none';
            // border box
            overlay.style.boxSizing = 'border-box';
            // overlay border removed so no yellow frame appears
            overlay.style.border = 'none';
            // message container
            const msg = document.createElement('div');
            msg.id = 'turnHighlightMsg';
            msg.style.position = 'absolute';
            // place the small turn message in the top-right corner of the overlay
            msg.style.top = '16px';
            msg.style.right = '16px';
            msg.style.transform = 'none';
            msg.style.background = 'rgba(255,255,255,0.95)';
            msg.style.color = '#0a5a2e';
            msg.style.padding = '12px 20px';
            msg.style.borderRadius = '10px';
            msg.style.fontWeight = '800';
            msg.style.fontSize = '20px';
            msg.style.boxShadow = '0 8px 24px rgba(0,0,0,0.25)';
            // remove the visible turn message
            msg.textContent = '';
            overlay.appendChild(msg);
            document.body.appendChild(overlay);
        }

        function showTurnHighlight(){
            ensureTurnHighlight();
            const overlay = document.getElementById('turnHighlight');
            if (!overlay) return;
            overlay.style.display = 'block';
        }

        function hideTurnHighlight(){
            const overlay = document.getElementById('turnHighlight');
            if (!overlay) return;
            overlay.style.display = 'none';
        }

        function updateTurnIndicator(turnName){
            ensureTurnIndicator();
            const d = document.getElementById('turnIndicator');
            if (!d) return;
            // Show the turn indicator to everyone (textual). Do not trigger the full-screen highlight.
            d.textContent = 'Turn: ' + (turnName || '-');
            d.style.display = 'block';
        }

        function removeTurnIndicator(){
            const existing = document.getElementById('turnIndicator');
            if (existing && existing.parentNode) {
                existing.parentNode.removeChild(existing);
            }
        }

        // error display
        let errorTimeout = null;
        function ensureErrorContainer(){
            if (document.getElementById('errorContainer')) return;
            const e = document.createElement('div');
            e.id = 'errorContainer';
            e.style.position = 'fixed';
            e.style.top = '20px';
            e.style.left = '50%';
            e.style.transform = 'translateX(-50%)';
            e.style.padding = '8px 12px';
            e.style.background = 'transparent';
            e.style.color = '#c00';
            e.style.fontWeight = '600';
            e.style.zIndex = '1100';
            document.body.appendChild(e);
        }

        function showError(msg, timeout = 4000){
            ensureErrorContainer();
            const e = document.getElementById('errorContainer');
            if (!e) return;
            e.textContent = msg;
            if (errorTimeout) clearTimeout(errorTimeout);
            if (timeout > 0) errorTimeout = setTimeout(()=>{ e.textContent = ''; }, timeout);
        }

        function clearError(){
            const e = document.getElementById('errorContainer');
            if (e) e.textContent = '';
            if (errorTimeout) { clearTimeout(errorTimeout); errorTimeout = null; }
        }

        function renderMessages(messages){
            if (!messagesContainer) return;
            while(messagesContainer.firstChild) messagesContainer.removeChild(messagesContainer.firstChild);
            messages.forEach(m => {
                const d = document.createElement('div');
                d.style.padding = '4px 0';
                // show only text (no timestamp)
                d.textContent = m.text;
                messagesContainer.appendChild(d);
            })
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function removeControlsOverlay(){
            const existing = document.getElementById('controlsOverlay');
            if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
            removeCardsOverlay();
        }

        function removeCardsOverlay(){
            const existing = document.getElementById('cardsOverlay');
            if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
        }

        // Track previous amounts to detect chip additions
        let previousAmounts = {};
        // Track previous chips to detect showdown winners
        let previousChips = {};
        let lastShowdownKey = null;

        // Render poker table with players around it
        function renderPokerTable(game) {
            const container = document.getElementById('pokerTable');
            if (!container) return;
            
            // Clear previous content
            while(container.firstChild) container.removeChild(container.firstChild);
            
            // Create table surface
            const tableSurface = document.createElement('div');
            tableSurface.className = 'table-surface';
            container.appendChild(tableSurface);
            
            // Create pot display
            const potDisplay = document.createElement('div');
            potDisplay.className = 'table-pot';
            const potValue = typeof game.pot === 'number' ? game.pot : (typeof game.value === 'number' ? game.value : 0);
            potDisplay.textContent = 'Pot: ' + potValue;
            container.appendChild(potDisplay);
            
            // Get players list
            const players = Array.isArray(game.clients) ? game.clients : [];
            if (players.length === 0) return;
            
            // Find current player index
            const currentPlayerIndex = players.findIndex(p => p.clientId === clientId);
            
            // Find user index and reorder so user is always at position for bottom
            let playersOrdered = [...players];
            if (currentPlayerIndex >= 0) {
                // Move user to last position (bottom of table)
                const userPlayer = playersOrdered.splice(currentPlayerIndex, 1)[0];
                playersOrdered.push(userPlayer);
            }
            
            // Position players around oval table
            const numPlayers = playersOrdered.length;
            const tableWidth = 600;
            const tableHeight = 400;
            const centerX = tableWidth / 2;
            const centerY = tableHeight / 2;
            const radiusX = 200;
            const radiusY = 130;
            
            // Get current turn index (from original array)
            const turnIndex = typeof game.turnIndex === 'number' ? game.turnIndex : 0;
            const currentTurnClientId = players[turnIndex] ? players[turnIndex].clientId : null;
            
            // Separate user from other players
            const otherPlayers = playersOrdered.filter(p => p.clientId !== clientId);
            const userPlayer = playersOrdered.find(p => p.clientId === clientId);
            
            // Position other players around the top and sides (not bottom)
            otherPlayers.forEach((player, index) => {
                const seat = document.createElement('div');
                seat.className = 'player-seat';
                seat.id = 'player-seat-' + player.clientId;
                
                const playerName = player.name || player.clientId;
                seat.textContent = playerName;
                
                // Check if this is the current turn
                if (player.clientId === currentTurnClientId) {
                    seat.classList.add('current-turn');
                }
                
                // Check if chips were added
                if (game.amountsAdded && typeof game.amountsAdded[player.clientId] === 'number') {
                    const currentAmount = game.amountsAdded[player.clientId];
                    const prevAmount = previousAmounts[player.clientId] || 0;
                    if (currentAmount > prevAmount) {
                        seat.classList.add('chip-added');
                        setTimeout(() => {
                            seat.classList.remove('chip-added');
                        }, 600);
                    }
                }
                
                // Position around oval (top and sides only, not bottom)
                // Distribute players across 270 degrees (from -45 to 225 degrees, skipping bottom 90 degrees)
                const numOther = otherPlayers.length;
                const startAngle = -Math.PI / 4; // -45 degrees
                const endAngle = 5 * Math.PI / 4; // 225 degrees
                const angleRange = endAngle - startAngle;
                const angle = startAngle + (index / Math.max(1, numOther - 1)) * angleRange;
                
                const x = centerX + radiusX * Math.cos(angle) - 44; // adjust for smaller tile
                const y = centerY + radiusY * Math.sin(angle) - 18;
                seat.style.left = x + 'px';
                seat.style.top = y + 'px';
                
                container.appendChild(seat);
            });
            
            // Position user at bottom
            if (userPlayer) {
                const seat = document.createElement('div');
                seat.className = 'player-seat user-seat';
                seat.id = 'player-seat-' + userPlayer.clientId;
                
                const playerName = userPlayer.name || userPlayer.clientId || username;
                seat.textContent = playerName;
                
                // Check if this is the current turn
                if (userPlayer.clientId === currentTurnClientId) {
                    seat.classList.add('current-turn');
                }
                
                // Check if chips were added
                if (game.amountsAdded && typeof game.amountsAdded[userPlayer.clientId] === 'number') {
                    const currentAmount = game.amountsAdded[userPlayer.clientId];
                    const prevAmount = previousAmounts[userPlayer.clientId] || 0;
                    if (currentAmount > prevAmount) {
                        seat.classList.add('chip-added');
                        setTimeout(() => {
                            seat.classList.remove('chip-added');
                        }, 600);
                    }
                }
                
                seat.style.bottom = '22px';
                seat.style.left = '50%';
                seat.style.transform = 'translateX(-50%)';
                
                container.appendChild(seat);
            }
            
            // Update previous amounts
            if (game.amountsAdded) {
                previousAmounts = {...game.amountsAdded};
            }
        }

        // Start a showdown animation: fade out pot, show each player's name + cards in center,
        // then highlight winner(s) after 2s, then restore pot.
        function startShowdownAnimation(game){
            if (!game || !game.showdown || !game.showdown.players) return;
            const showdownPlayers = game.showdown.players;
            const potElem = document.getElementById('numberDisplay') || document.querySelector('.table-pot');
            if (!potElem) return;
            // fade out pot
            potElem.style.transition = 'opacity 400ms ease';
            potElem.style.opacity = '0.12';

            // create showdown area centered over pot
            const rect = potElem.getBoundingClientRect();
            const area = document.createElement('div');
            area.id = 'showdownArea';
            area.style.position = 'fixed';
            area.style.left = (rect.left + rect.width/2) + 'px';
            area.style.top = (rect.top + rect.height/2) + 'px';
            area.style.transform = 'translate(-50%, -50%)';
            area.style.display = 'flex';
            area.style.gap = '18px';
            area.style.zIndex = '2500';
            area.style.alignItems = 'flex-start';
            document.body.appendChild(area);

            // create player blocks
            const ids = Object.keys(showdownPlayers);
            ids.forEach(id => {
                const p = showdownPlayers[id];
                const block = document.createElement('div');
                block.className = 'showdown-player';
                block.dataset.clientId = id;
                // name marker
                const name = document.createElement('div');
                name.className = 'showdown-name';
                // find display name from game.clients
                const clientObj = (game.clients||[]).find(c=>c.clientId===id);
                name.textContent = (clientObj && clientObj.name) ? clientObj.name : id;
                name.style.fontWeight = '700';
                name.style.marginBottom = '6px';
                name.style.textAlign = 'center';
                // card container
                const cards = document.createElement('div');
                cards.style.display = 'flex';
                cards.style.gap = '6px';
                const priv = Array.isArray(p.private) ? p.private : [];
                priv.forEach(code => {
                    const c = document.createElement('div');
                    c.className = 'showdown-card';
                    c.style.minWidth = '44px';
                    c.style.height = '64px';
                    c.style.borderRadius = '6px';
                    c.style.background = '#fff';
                    c.style.color = '#0a5a2e';
                    c.style.display = 'flex';
                    c.style.alignItems = 'center';
                    c.style.justifyContent = 'center';
                    c.style.fontWeight = '700';
                    c.textContent = code || '';
                    cards.appendChild(c);
                });
                block.appendChild(name);
                block.appendChild(cards);
                area.appendChild(block);
            });

            // capture previous chips snapshot now
            const prevSnapshot = Object.assign({}, previousChips || {});
            // after 5s, determine winner(s) by chip delta and enlarge their cards
            setTimeout(()=>{
                const deltas = {};
                ids.forEach(id => {
                    const now = (game.chips && typeof game.chips[id] === 'number') ? game.chips[id] : 0;
                    const prev = (prevSnapshot && typeof prevSnapshot[id] === 'number') ? prevSnapshot[id] : 0;
                    deltas[id] = now - prev;
                });
                // find max delta
                let maxDelta = -Infinity;
                ids.forEach(id => { if (deltas[id] > maxDelta) maxDelta = deltas[id]; });
                const winners = ids.filter(id => deltas[id] === maxDelta && maxDelta > 0);
                // enlarge winner cards after 5s
                ids.forEach(id => {
                    const block = area.querySelector('.showdown-player[data-client-id="'+id+'"]');
                    if (!block) return;
                    if (winners.includes(id)) {
                        // enlarge each card inside the winner block
                        const cards = block.querySelectorAll('.showdown-card');
                        cards.forEach(c => { c.style.transition = 'transform 300ms ease'; c.style.transform = 'scale(1.25)'; });
                        const nameEl = block.querySelector('.showdown-name'); if (nameEl) nameEl.style.fontSize = '18px';
                    }
                });
            }, 5000);
            // cleanup after 13s: remove showdown and restore pot, update previousChips
            setTimeout(()=>{
                try { if (area && area.parentNode) area.parentNode.removeChild(area); } catch(e){}
                potElem.style.opacity = '1';
                previousChips = Object.assign({}, game.chips || {});
            }, 13000);
        }

        // render player's private cards into cardsOverlay
        function renderCards(cards){
            const container = document.getElementById('cardsOverlay');
            if (!container) return;
            const cardsRow = document.getElementById('cardsRow') || container;
            while(cardsRow.firstChild) cardsRow.removeChild(cardsRow.firstChild);
            (cards || []).forEach(code => {
                // parse rank and suit from server code like 'AS', '10H', 'JD'
                if (!code) return;
                const suitChar = code.slice(-1).toUpperCase();
                const rank = code.slice(0, -1);
                const suitMap = { 'S': '♠', 'H': '♥', 'D': '♦', 'C': '♣' };
                const suitSym = suitMap[suitChar] || suitChar;
                const isRed = suitChar === 'H' || suitChar === 'D';

                // wrapper for hover-to-reveal
                const wrapper = document.createElement('div');
                wrapper.className = 'card-wrapper';
                wrapper.style.margin = '0 6px';

                // face (hidden until hover) - smaller sizes
                const face = document.createElement('div');
                face.className = 'card-face';
                face.style.background = 'linear-gradient(135deg, #ffffff 0%, #f8f8f8 100%)';
                face.style.color = isRed ? '#d32f2f' : '#212121';
                face.style.fontFamily = 'Georgia, serif';
                const top = document.createElement('div');
                top.style.fontSize = '12px';
                top.style.fontWeight = '700';
                top.style.alignSelf = 'flex-start';
                top.style.lineHeight = '1';
                top.textContent = rank;
                const middle = document.createElement('div');
                middle.style.flex = '1';
                middle.style.display = 'flex';
                middle.style.alignItems = 'center';
                middle.style.justifyContent = 'center';
                middle.style.fontSize = '26px';
                middle.style.lineHeight = '1';
                middle.textContent = suitSym;
                const bottom = document.createElement('div');
                bottom.style.fontSize = '12px';
                bottom.style.fontWeight = '700';
                bottom.style.alignSelf = 'flex-end';
                bottom.style.lineHeight = '1';
                bottom.style.transform = 'rotate(180deg)';
                bottom.textContent = rank;
                face.appendChild(top);
                face.appendChild(middle);
                face.appendChild(bottom);

                // back (visible by default) with hover hint
                const back = document.createElement('div');
                back.className = 'card-back';
                back.textContent = 'hover to reveal';

                wrapper.appendChild(face);
                wrapper.appendChild(back);
                cardsRow.appendChild(wrapper);
            })
        }

        // community card area
        function ensureCommunityContainer(){
            if (document.getElementById('communityOverlay')) return;
            const c = document.createElement('div');
            c.id = 'communityOverlay';
            c.style.position = 'fixed';
            // position the community (river) reliably above the player's cards
            // move it up by about 1/8th of the viewport height so it sits between pot and your cards
            c.style.bottom = 'calc(160px + 12.5vh)';
            c.style.left = '50%';
            c.style.transform = 'translateX(-50%)';
            c.style.display = 'flex';
            c.style.flexDirection = 'column';
            c.style.gap = '8px';
            c.style.alignItems = 'center';
            c.style.zIndex = '1050';
            // label (text set by renderCommunity)
            const lbl = document.createElement('div');
            lbl.id = 'communityLabel';
            lbl.textContent = '';
            lbl.style.fontWeight = '700';
            lbl.style.fontSize = '20px';
            lbl.style.marginBottom = '8px';
            lbl.style.color = '#fff';
            lbl.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
            c.appendChild(lbl);
            const row = document.createElement('div');
            row.id = 'communityRow';
            row.style.display = 'flex';
            row.style.gap = '10px';
            row.style.marginTop = '6px';
            c.appendChild(row);
            document.body.appendChild(c);
        }

        function removeCommunityContainer(){
            const existing = document.getElementById('communityOverlay');
            if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
        }

        function ensureYourChipsContainer(){
            if (document.getElementById('yourChipsWidget')) return;
            const c = document.createElement('div');
            c.id = 'yourChipsWidget';
            c.style.position = 'fixed';
            c.style.left = '20px';
            c.style.bottom = '20px';
            c.style.display = 'flex';
            c.style.flexDirection = 'column';
            c.style.alignItems = 'center';
            c.style.gap = '8px';
            c.style.zIndex = '1200';
            c.style.background = 'rgba(255,255,255,0.98)';
            c.style.padding = '12px 16px';
            c.style.borderRadius = '12px';
            c.style.border = '2px solid rgba(212,175,55,0.3)';
            c.style.boxShadow = '0 8px 24px rgba(0,0,0,0.3)';


            const icon = document.createElement('div');
            icon.textContent = 'Your chips';
            icon.style.fontSize = '12px';
            icon.style.fontWeight = '600';
            icon.style.display = 'flex';
            icon.style.alignItems = 'center';
            icon.style.gap = '6px';
                const coin = document.createElement('span');
            coin.textContent = '🪙';
            coin.style.fontSize = '14px';
            icon.insertBefore(coin, icon.firstChild);

            const val = document.createElement('div');
            val.id = 'yourChipsValue';
            val.textContent = '0';
            val.style.fontSize = '32px';
            val.style.fontWeight = '700';
            val.style.lineHeight = '1';

            c.appendChild(icon);
            c.appendChild(val);
            document.body.appendChild(c);
        }
        
        function updatePlayerList(game) {
            ensureTopPlayerBar();
            const topBar = document.getElementById('topPlayerBar');
            if (!topBar) return;
            while(topBar.firstChild) topBar.removeChild(topBar.firstChild);
            const players = Array.isArray(game.clients) ? game.clients : [];
            const turnIndex = typeof game.turnIndex === 'number' ? game.turnIndex : 0;
            const currentTurnClientId = (Array.isArray(game.clients) && game.clients[turnIndex]) ? game.clients[turnIndex].clientId : null;
            players.forEach(player => {
                const tile = document.createElement('div');
                tile.style.width = '88px';
                tile.style.height = '88px';
                tile.style.background = 'rgba(255,255,255,0.95)';
                tile.style.borderRadius = '8px';
                // default: no visible border
                tile.style.border = '2px solid transparent';
                tile.style.display = 'flex';
                tile.style.flexDirection = 'column';
                tile.style.alignItems = 'center';
                tile.style.justifyContent = 'center';
                tile.style.margin = '4px';
                tile.style.boxShadow = '0 6px 16px rgba(0,0,0,0.15)';
                tile.style.fontWeight = '700';
                tile.style.color = '#0a5a2e';
                tile.style.textAlign = 'center';
                tile.id = 'player-tile-' + player.clientId;

                const nameDiv = document.createElement('div');
                nameDiv.textContent = player.name || player.clientId;
                nameDiv.style.fontSize = '12px';
                nameDiv.style.marginBottom = '6px';
                nameDiv.style.overflow = 'hidden';
                nameDiv.style.textOverflow = 'ellipsis';
                nameDiv.style.whiteSpace = 'nowrap';
                nameDiv.style.width = '72px';

                const chipsDiv = document.createElement('div');
                const chipVal = (game.chips && typeof game.chips[player.clientId] === 'number') ? game.chips[player.clientId] : 0;
                chipsDiv.textContent = chipVal + ' 🪙';
                chipsDiv.style.fontSize = '12px';
                chipsDiv.style.marginTop = '4px';
                chipsDiv.style.color = '#555';

                // If this is a showdown, render small private cards and best-hand text inside the tile
                const sd = (game.showdown && game.showdown.players && game.showdown.players[player.clientId]) ? game.showdown.players[player.clientId] : null;
                if (sd) {
                    const bestDiv = document.createElement('div');
                    bestDiv.textContent = sd.bestText || '';
                    bestDiv.style.fontSize = '11px';
                    bestDiv.style.fontWeight = '700';
                    bestDiv.style.marginTop = '4px';
                    bestDiv.style.color = '#222';
                    bestDiv.style.width = '80%';
                    bestDiv.style.whiteSpace = 'nowrap';
                    bestDiv.style.overflow = 'hidden';
                    bestDiv.style.textOverflow = 'ellipsis';

                    const miniRow = document.createElement('div');
                    miniRow.style.display = 'flex';
                    miniRow.style.gap = '4px';
                    miniRow.style.marginTop = '6px';
                    (sd.private || []).forEach(code => {
                        if (!code) return;
                        const suitChar = code.slice(-1).toUpperCase();
                        const rank = code.slice(0, -1);
                        const suitMap = { 'S': '♠', 'H': '♥', 'D': '♦', 'C': '♣' };
                        const suitSym = suitMap[suitChar] || suitChar;
                        const mini = document.createElement('div');
                        mini.style.width = '34px';
                        mini.style.height = '50px';
                        mini.style.border = '1px solid #333';
                        mini.style.borderRadius = '6px';
                        mini.style.display = 'flex';
                        mini.style.flexDirection = 'column';
                        mini.style.alignItems = 'center';
                        mini.style.justifyContent = 'center';
                        mini.style.fontSize = '12px';
                        mini.style.background = '#fff';
                        mini.style.color = (suitChar === 'H' || suitChar === 'D') ? '#d32f2f' : '#111';
                        mini.textContent = rank + suitSym;
                        miniRow.appendChild(mini);
                    });

                    tile.appendChild(bestDiv);
                    tile.appendChild(miniRow);
                }

                tile.appendChild(nameDiv);
                tile.appendChild(chipsDiv);

                // Do not show yellow border highlight on player tiles. Keep borders transparent for all tiles.
                tile.style.border = '2px solid transparent';

                topBar.appendChild(tile);
            });
        }

        function ensureTopPlayerBar(){
            if (document.getElementById('topPlayerBar')) return;
            const bar = document.createElement('div');
            bar.id = 'topPlayerBar';
            bar.style.position = 'fixed';
            bar.style.top = '8px';
            bar.style.left = '50%';
            bar.style.transform = 'translateX(-50%)';
            bar.style.display = 'flex';
            bar.style.flexDirection = 'row';
            bar.style.alignItems = 'center';
            bar.style.justifyContent = 'center';
            bar.style.gap = '8px';
            bar.style.zIndex = '1400';
            bar.style.padding = '6px 8px';
            bar.style.background = 'transparent';
            document.body.appendChild(bar);
        }

        function removeYourChipsContainer(){
            const existing = document.getElementById('yourChipsWidget');
            if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
        }

        // remove all non-lobby game graphics (used when leaving a game)
        function removeAllGameGraphics(){
            // clear main board
            const board = document.getElementById('divBoard');
            if (board) { while(board.firstChild) board.removeChild(board.firstChild); }
            // clear players panel (removes 'current game code' text)
            const dp = document.getElementById('divPlayers'); if (dp) { while(dp.firstChild) dp.removeChild(dp.firstChild); }
            // top player bar
            const top = document.getElementById('topPlayerBar'); if (top && top.parentNode) top.parentNode.removeChild(top);
            // messages, chips, community, controls, cards, turn indicator
            try { removeMessagesContainer(); } catch(e){}
            try { removeYourChipsContainer(); } catch(e){}
            try { removeCommunityContainer(); } catch(e){}
            try { removeControlsOverlay(); } catch(e){}
            try { removeCardsOverlay(); } catch(e){}
            try { removeTurnIndicator(); } catch(e){}
            try { removeLeaveButton(); } catch(e){}
            // timers and blind notices
            const tt = document.getElementById('turnTimer'); if (tt && tt.parentNode) tt.parentNode.removeChild(tt);
            const blind = document.getElementById('blindNotice'); if (blind && blind.parentNode) blind.parentNode.removeChild(blind);
            // misc displays created during game
            ['numberDisplay','roundDisplay','requiredAddDisplay','yourAddedDisplay','maxDisplay','gameCodeDisplay','waitingForHost','startGameButton'].forEach(id => {
                const el = document.getElementById(id); if (el && el.parentNode) el.parentNode.removeChild(el);
            });
        }

        // blind notice (shows "Small Blind" / "Big Blind" to the local blind player)
        let _blindNoticeTimeout = null;
        function ensureBlindNotice(){
            if (document.getElementById('blindNotice')) return;
            const d = document.createElement('div');
            d.id = 'blindNotice';
            d.style.position = 'fixed';
            d.style.bottom = '20px';
            d.style.right = '20px';
            d.style.background = 'linear-gradient(135deg, #ffd700 0%, #ffed4e 100%)';
            d.style.color = '#0a5a2e';
            d.style.padding = '12px 20px';
            d.style.border = '2px solid #ffb800';
            d.style.borderRadius = '10px';
            d.style.fontWeight = '700';
            d.style.fontSize = '16px';
            d.style.zIndex = '1300';
            d.style.boxShadow = '0 8px 24px rgba(255,184,0,0.5)';
            d.style.display = 'none';
            document.body.appendChild(d);
        }

        // Leave button (allows local player to exit the game)
        function ensureLeaveButton(){
            if (document.getElementById('leaveBtn')) return;
            const b = document.createElement('button');
            b.id = 'leaveBtn';
            b.textContent = 'Leave Game';
            b.style.position = 'fixed';
            b.style.top = '50%';
            b.style.left = '20px';
            b.style.transform = 'translateY(-50%)';
            b.style.zIndex = '1200';
            b.style.padding = '8px 12px';
            b.style.background = 'rgba(255,255,255,0.95)';
            b.style.border = '2px solid rgba(0,0,0,0.08)';
            b.style.borderRadius = '8px';
            b.style.fontWeight = '700';
            b.style.boxShadow = '0 6px 16px rgba(0,0,0,0.12)';
            b.style.color = '#000';
            b.addEventListener('click', () => {
                try {
                    const payLoad = { method: 'leave', clientId: clientId, gameId: gameId };
                    if (ws && ws.readyState === WebSocket.OPEN) wsSend(JSON.stringify(payLoad));
                } catch (e) { console.error('Leave send failed', e); }
                // immediate local cleanup and return to lobby
                try { removeAllGameGraphics(); } catch (e) { console.error('cleanup failed', e); }
                showScreen('lobbyScreen');
                // clear local game state
                gameId = null;
            });
            document.body.appendChild(b);
        }

        function removeLeaveButton(){
            const existing = document.getElementById('leaveBtn');
            if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
        }
        function wsSend(payload) {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
        console.warn("WS not ready, message dropped:", payload);
        return;
        }
        console.log("preparing to send")
        ws.send(JSON.stringify(payload));
        console.log(payload)
        }

        function showBlindNotice(text, timeout = 4000){
            ensureBlindNotice();
            const d = document.getElementById('blindNotice');
            if (!d) return;
            d.textContent = text;
            d.style.display = 'block';
            if (_blindNoticeTimeout) clearTimeout(_blindNoticeTimeout);
            if (timeout > 0) _blindNoticeTimeout = setTimeout(()=>{ d.style.display = 'none'; _blindNoticeTimeout = null; }, timeout);
        }

        function clearBlindNotice(){
            const d = document.getElementById('blindNotice');
            if (d) d.style.display = 'none';
            if (_blindNoticeTimeout) { clearTimeout(_blindNoticeTimeout); _blindNoticeTimeout = null; }
        }

        function renderCommunity(cards, round){
            const container = document.getElementById('communityOverlay');
            if (!container) return;
            const row = document.getElementById('communityRow');
            const lbl = document.getElementById('communityLabel');
            if (!row || !lbl) return;
            // show the label only when there are community cards OR at the start of round 2+
            const hasCards = Array.isArray(cards) && cards.length > 0;
            const showLabel = hasCards || (typeof round === 'number' && round >= 2);
            lbl.textContent = showLabel ? 'River' : '';
            lbl.style.color = '#fff';
            lbl.style.fontSize = '20px';
            lbl.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
            while(row.firstChild) row.removeChild(row.firstChild);
            (cards || []).forEach(code => {
                if (!code) return;
                const suitChar = code.slice(-1).toUpperCase();
                const rank = code.slice(0, -1);
                const suitMap = { 'S': '♠', 'H': '♥', 'D': '♦', 'C': '♣' };
                const suitSym = suitMap[suitChar] || suitChar;
                const isRed = suitChar === 'H' || suitChar === 'D';

                const d = document.createElement('div');
                // smaller river card sizes
                d.style.minWidth = '56px';
                d.style.width = '56px';
                d.style.height = '86px';
                d.style.border = '1px solid #333';
                d.style.borderRadius = '8px';
                d.style.display = 'flex';
                d.style.flexDirection = 'column';
                d.style.padding = '6px';
                d.style.background = 'linear-gradient(135deg, #ffffff 0%, #f8f8f8 100%)';
                d.style.boxShadow = '0 6px 12px rgba(0,0,0,0.22), inset 0 1px 0 rgba(255,255,255,0.8)';
                d.style.color = isRed ? '#d32f2f' : '#212121';
                d.style.fontFamily = 'Georgia, serif';
                d.style.transition = 'transform 0.16s, box-shadow 0.16s';
                d.style.cursor = 'default';

                const top = document.createElement('div');
                top.style.fontSize = '12px';
                top.style.fontWeight = '700';
                top.style.alignSelf = 'flex-start';
                top.style.lineHeight = '1';
                top.textContent = rank;

                const middle = document.createElement('div');
                middle.style.flex = '1';
                middle.style.display = 'flex';
                middle.style.alignItems = 'center';
                middle.style.justifyContent = 'center';
                middle.style.fontSize = '26px';
                middle.style.lineHeight = '1';
                middle.textContent = suitSym;

                const bottom = document.createElement('div');
                bottom.style.fontSize = '12px';
                bottom.style.fontWeight = '700';
                bottom.style.alignSelf = 'flex-end';
                bottom.style.lineHeight = '1';
                bottom.style.transform = 'rotate(180deg)';
                bottom.textContent = rank;

                d.appendChild(top);
                d.appendChild(middle);
                d.appendChild(bottom);
                row.appendChild(d);
            })
        }

        
    </script>
</body>
</html>
